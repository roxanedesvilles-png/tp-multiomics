---
title: "Analyse Intégrative Multi-Omique – Dataset T2D"
author: "Amory Antao, Hugo Breton, Appoline Nabi, Roxane Desvilles"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggraph)
library(reshape2)
library(tibble)
library(purrr)
library(tidyverse)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(mixOmics)
library(gprofiler2)
library(minet)
library(clusterProfiler)
```

# **1. Contexte et objectifs - Présentation du jeu de données**

# **2. Exploration du dataset**

**Commentaires :**

Chaque bloc (RNA, protéome, cytokynes) contient un nombre distinct de features.

Les échantillons sont partagés et décrits dans sample_info (avec la variable mode : IR vs IS).

```{r}
data_t2d <- readRDS("/Users/roxanedesvilles/Documents/Pharmacie P5 DESCARTES/6A - M2 Bioinformatique biologique (UPc) 2025-2026/S1/UE Bioinformatique des omiques avancées/UE 8 - Production et gestion des big data en biologie/tp-multiomics/data_t2d.Rds")

# Vérifier les blocs
lapply(data_t2d, dim)

# Nombre d'échantillons et de features
n_samples <- nrow(data_t2d$sample_info)
n_features <- sapply(data_t2d[1:3], ncol)
n_samples; n_features

# Classes disponibles
table(data_t2d$sample_info$mode)
```

**Commentaires :**

Bloc RNA : 8933 features.

Bloc protein : 233 features.

Bloc cytokyne : 66 features.

Il y a 15 échantillons au total. 7 sont insulino-résistants (IR), et 8 sont insulino-sensibles (IS).

# **3. Analyse préliminaire**

## *a. Visualisation des données : par échantillon, par classe, par bloc omique*

**Commentaire :** Pour manipuler plus facilement les données, on transforme les blocs en matrices, puis on utilise tidyverse pour faire un pivot.

```{r}
# Extraction des matrices
rna_mat <- as.matrix(data_t2d$RNA)
prot_mat <- as.matrix(data_t2d$protein)
cyto_mat <- as.matrix(data_t2d$cytokyne)

# Récupération de l'info classe
classes <- data_t2d$sample_info$mode
samples <- rownames(data_t2d$sample_info)

# Fonction pour convertir en tidy format
tidy_block <- function(mat, block_name){
  df <- as.data.frame(mat)
  df$Sample <- rownames(df)
  df$Class <- classes
  df_melt <- melt(df, id.vars=c("Sample","Class"))
  df_melt$Block <- block_name
  return(df_melt)
}

# Tidy pour chaque bloc
df_rna <- tidy_block(rna_mat, "RNA")
df_prot <- tidy_block(prot_mat, "Protein")
df_cyto <- tidy_block(cyto_mat, "Cytokine")

# Combiner tous les blocs
df_all <- bind_rows(df_rna, df_prot, df_cyto)
```

### a.1. Par échantillon

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Sample, y=value, fill=Block)) +
  geom_boxplot() +
  facet_wrap(~Block, scales="free") +
  theme_bw() +
  theme(axis.text.x=element_text(angle=45, hjust=1)) +
  labs(title="Distribution par échantillon", y="Expression")
```

### a.2. Par classe

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Class, y=value, fill=Block)) +
  geom_boxplot() +
  facet_wrap(~Block, scales="free") +
  theme_bw() +
  labs(title="Distribution par classe", y="Expression")
```

### a.3. Par bloc omique

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Block, y=value, fill=Block)) +
  geom_boxplot() +
  theme_bw() +
  labs(title="Distribution par bloc omique", y="Expression")
```

## *b. Mise en forme et transformation des données*

**Commentaire :** Il faut d'abord vérifier si les données ont été log-transformées et/ou centrées-réduites.

-   Pour le bloc RNA :

```{r, fig.width=14, fig.height=7}
# Calcul CV par gène
cv_rna <- apply(rna_mat, 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))

# Résumé
summary(cv_rna)

# Histogramme
hist(cv_rna, breaks=50, main="CV RNA", xlab="Coefficient de variation", col="green")
abline(v=0.4, col="red", lwd=2)
```

**Commentaire :** La médiane de la série est d'environ 0.61, avec des valeurs allant de 0.03 à 3.87. On choisit un seuil de 0.4 pour conserver la plupart des gènes.

```{r}
# Filtrage
rna_keep <- !is.na(cv_rna) & cv_rna >= 0.4
rna_filt <- rna_mat[, rna_keep, drop = FALSE]

# Scaling
rna_scaled <- scale(rna_filt)
```

Les données RNA sont normalisées.

-   Pour le bloc protein :

```{r, fig.width=14, fig.height=7}
# Écart-type par protéine (feature)
sd_prot <- apply(prot_mat, 2, sd, na.rm = TRUE)
summary(sd_prot)

# Histogramme
hist(sd_prot, breaks=50, main="SD Protein", xlab="Standard deviation", col="coral")
abline(v=0.4, col="red", lwd=2)
```

**Commentaire :** Ici, on choisit de calculer le sd et non le CV. En effet, les données du bloc protein ont déjà été log-transformées (valeurs très négatives). Calculer le CV n'aurait pas de sens ici.

La médiane étant de 0.58 environ (pour des valeurs allant de 0.096 à 3.29), on choisit un seuil de sd de 0.4, qui semble un bon compromis pour filtrer suffisamment de gènes peu variables, tout en restant permissif.

```{r}
# Filtrage
prot_keep <- !is.na(sd_prot) & sd_prot >= 0.4
prot_filt <- prot_mat[, prot_keep, drop = FALSE]

# Scaling
prot_scaled <- scale(prot_filt)
```

Les données protein sont normalisées.

-   Pour le bloc cytokyne

```{r, fig.width=14, fig.height=7}
# Calcul CV par gène
cv_cyto <- apply(cyto_mat, 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))
summary(cv_cyto)

# Histogramme
hist(cv_cyto, breaks=50, main="CV Cytokine", xlab="Coefficient de variation", col="#C8A2C8")
abline(v=0.15, col="red", lwd=2)
```

**Commentaire :** Les valeurs de CV sont positives et petites (de 0.02 à 0.98). On choisit un seuil de 0.15, suffisamment permissif sachant la petite taille de ce bloc dans le dataset.

```{r}
# Filtrage
cyto_keep <- !is.na(cv_cyto) & cv_cyto >= 0.15
cyto_filt <- cyto_mat[, cyto_keep, drop = FALSE]

# Scaling
cyto_scaled <- scale(cyto_filt)
```

Les données cytokyne sont normalisées.

Visualisation des données après preprocessing

```{r, fig.width=14, fig.height=7}
# Supposons que rna_scaled, prot_scaled, cyto_scaled existent après filtrage/scaling
tidy_scaled <- function(mat, block_name){
  df <- as.data.frame(mat)
  df$Sample <- rownames(df)
  df$Class <- classes
  df_melt <- melt(df, id.vars=c("Sample","Class"))
  df_melt$Block <- block_name
  return(df_melt)
}

df_rna_scaled <- tidy_scaled(rna_scaled, "RNA")
df_prot_scaled <- tidy_scaled(prot_scaled, "Protein")
df_cyto_scaled <- tidy_scaled(cyto_scaled, "Cytokine")

df_all_scaled <- bind_rows(df_rna_scaled, df_prot_scaled, df_cyto_scaled)

# Boxplot par bloc après traitement
ggplot(df_all_scaled, aes(x=Block, y=value, fill=Block)) +
  geom_boxplot() +
  theme_bw() +
  labs(title="Distribution par bloc (après filtrage et scaling)", y="Expression (scaled)")
```

## *c. Nombre de features après filtrage*

```{r}
# Nombre de features restantes
sum(rna_keep)    # RNA
sum(prot_keep)   # Protein
sum(cyto_keep)   # Cytokine
```

```{r}
cat("RNA :", sum(rna_keep), "features\n")
cat("Protein :", sum(prot_keep), "features\n")
cat("Cytokine :", sum(cyto_keep), "features\n")
```

**Commentaire :** Il reste 5844 features après filtrage du bloc RNA, 163 features après filtrage du bloc protein, et 28 features après filtrage du bloc cytokyne.

## *d. Gènes et protéines les plus variables*

```{r}
# Pour RNA
top_rna <- sort(cv_rna[rna_keep], decreasing=TRUE)
head(top_rna, 10)  # 10 gènes les plus variables

# Pour Protein
top_prot <- sort(sd_prot[prot_keep], decreasing=TRUE)
head(top_prot, 10)

# Pour Cytokine
top_cyto <- sort(cv_cyto[cyto_keep], decreasing=TRUE)
head(top_cyto, 10)
```

## *e. Ces gènes sont-ils traduits ? Présents dans les données protéomiques ?*

Pour évaluer si les gènes les plus variables au niveau transcriptomique sont traduits, les identifiants ENSEMBL des gènes sélectionnés ont été annotés à l’aide de la base org.Hs.eg.db. Les correspondances SYMBOL et UNIPROT ont été extraites via AnnotationDbi::select().

```{r}
cv_rna_filtered <- cv_rna[rna_keep]

# 1. Annotation : SYMBOL + UNIPROT pour les gènes RNA
res_annot <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = names(cv_rna_filtered),
  keytype = "ENSEMBL",
  columns = c("SYMBOL", "UNIPROT")
)
```

```{r}
# 2. Identifier les gènes les plus variables
top_rna_names <- names(sort(cv_rna_filtered, decreasing = TRUE))[1:10]
top_rna_annot <- res_annot %>% filter(ENSEMBL %in% top_rna_names)
```

```{r}
# 3. Vérifier lesquels sont traduits (ont un UNIPROT)
top_rna_annot$Traduit <- ifelse(is.na(top_rna_annot$UNIPROT), "Non", "Oui")
```

```{r}
# 4. Petit résumé
table(top_rna_annot$Traduit)
```

```{r}
# 5. (Optionnel) – Exporter un tableau propre
top_rna_annot <- top_rna_annot %>%
  dplyr::arrange(desc(ENSEMBL)) %>%
  dplyr::select(ENSEMBL, SYMBOL, UNIPROT, Traduit)

top_rna_annot
```

```{r, fig.width=14, fig.height=7}
traduit_df <- top_rna_annot %>%
  count(Traduit)

ggplot(traduit_df, aes(x = Traduit, y = n, fill = Traduit)) +
  geom_bar(stat = "identity", width = 0.5) +
  geom_text(aes(label = n), vjust = -0.4, size = 5) +
  scale_fill_manual(values = c("Oui" = "mediumorchid", "Non" = "grey70")) +
  theme_bw() +
  labs(
    title = "Proportion de gènes RNA traduits (présents dans le protéome)",
    x = "",
    y = "Nombre de gènes"
  ) +
  theme(
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5),
    legend.position = "none"
  )
```

**Commentaires :** Après filtrage, tous les gènes RNA les plus variables ont une correspondance dans la base UniProt. ls sont donc potentiellement traduits et présents dans le bloc protéomique.

Cela reflète une bonne cohérence entre les blocs RNA et protéomique, malgré les différences d’amplitude observées lors de la normalisation.

# **4. Analyse en composantes principales : PCA et sPCA**

## *a. PCA*

### a.1. PCA sur le bloc RNA

```{r, fig.width=14, fig.height=7}
rna <- rna_scaled
pca_rna <- pca(rna, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_rna, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - RNA")

# Contribution de chaque PC
plotVar(pca_rna, title = "Variables - RNA")

# Évaluer le nombre de PC pertinentes
pca_rna$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_rna$prop_expl_var$X, 3)  # lisible
cumsum(pca_rna$prop_expl_var$X)    # variance cumulée
```

PC1 et PC2 expliquent le mieux la variance des données (32,6% de variance cumulée expliquée).

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_rna <- pca_rna$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_rna, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA RNA")
abline(h=0.09, col="red", lty=2)  # seuil optionnel pour voir les PCs importantes
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_rna <- as.data.frame(pca_rna$variates$X)
pca_scores_rna$sample <- rownames(pca_scores_rna)
pca_scores_rna$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
library(ggrepel)
pca_scores_rna$outlier <- FALSE
center_IR <- colMeans(pca_scores_rna[pca_scores_rna$class=="IR", c("PC1","PC2")])
dist_IR <- sqrt((pca_scores_rna$PC1 - center_IR[1])^2 + (pca_scores_rna$PC2 - center_IR[2])^2)
pca_scores_rna$outlier[which.max(dist_IR)] <- TRUE

ggplot(pca_scores_rna, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  geom_point(data=subset(pca_scores_rna, outlier==TRUE), 
             color="red", size=4, shape=8) +  # point rouge étoilé
  geom_text_repel(data=subset(pca_scores_rna, outlier==TRUE), 
                  aes(label=sample), color="red") +
  stat_ellipse(level=0.95) +
  theme_minimal() +
  labs(title="PCA RNA avec outlier", x="PC1", y="PC2")
```

**Commentaire de l'ellipse :** Les deux groupes IS et IR ont une variance similaire sur PC1 et 2. La dispersion des échantillons est comparable. Le groupe IS est plus homogène (l'ellipse de IS est incluse dans celle d'IR). Cette PCA montre que les principales sources de variations ne distinguent pas parfaitement les deux groupes. D'autres blocs pourraient mieux montrer cette séparation.

L'outlier pourrait avoir un profil transcriptionnel un peu différent.

### a.2. PCA sur le bloc protein

```{r, fig.width=14, fig.height=7}
prot <- prot_scaled
pca_prot <- pca(prot, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_prot, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - Protein")

# Contribution de chaque PC
plotVar(pca_prot, title = "Variables - Protein")

# Évaluer le nombre de PC pertinentes
pca_prot$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_prot$prop_expl_var$X, 3)  # lisible
cumsum(pca_prot$prop_expl_var$X)    # variance cumulée
```

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_prot <- pca_prot$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_prot, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA Protein")
abline(h=0.155, col="red", lty=2)  # seuil optionnel pour voir les PCs importantes
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_prot <- as.data.frame(pca_prot$variates$X)
pca_scores_prot$sample <- rownames(pca_scores_prot)
pca_scores_prot$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
ggplot(pca_scores_prot, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  stat_ellipse(level=0.95) +  # ellipse 95% pour chaque groupe
  theme_minimal() +
  labs(title="PCA Protein", x="PC1", y="PC2")
```

**Commentaire de l'ellipse :** Pour la PCA des protéines, les deux premières composantes principales expliquent une proportion plus élevée de variance que pour les données RNA, ce qui indique que la structure globale des protéines est mieux capturée par les deux premières PC. Les ellipses des groupes IS et IR sont horizontales, mais ont des tailles différentes : le groupe IR présente une dispersion plus large, alors que le groupe IS est plus concentré. Contrairement aux RNA, aucun point n’est un outlier et les chevauchements sont limités, ce qui traduit une séparation plus nette des groupes dans l’espace des deux premières composantes.

### a.3. Pour le bloc cytokyne

```{r, fig.width=14, fig.height=7}
cyto <- cyto_scaled
pca_cyto <- pca(cyto, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_cyto, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - Cytokine")

# Contribution de chaque PC
plotVar(pca_cyto, title = "Variables - Cytokine")

# Évaluer le nombre de PC pertinentes
pca_cyto$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_cyto$prop_expl_var$X, 3)  # lisible
cumsum(pca_cyto$prop_expl_var$X)    # variance cumulée
```

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_cyto <- pca_cyto$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_cyto, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA Cytokine")
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_cyto <- as.data.frame(pca_cyto$variates$X)
pca_scores_cyto$sample <- rownames(pca_scores_cyto)
pca_scores_cyto$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
ggplot(pca_scores_cyto, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  stat_ellipse(level=0.95) +  # ellipse 95% pour chaque groupe
  theme_minimal() +
  labs(title="PCA Cytokine", x="PC1", y="PC2")
```

**Commentaire :** Pour la PCA des cytokines, les deux premières composantes expliquent moins de variance que pour les protéines, mais restent informatives. Les ellipses des groupes IS et IR se croisent, indiquant un certain chevauchement entre les profils des deux groupes. Les différentes inclinaisons des ellipses IR et IS traduisentt des orientations différentes de la variation dans l’espace des deux premières PC. Aucun point n’apparaît comme outlier, suggérant que toutes les observations sont relativement cohérentes avec la structure globale des groupes.

## *b. sPCA*

```{r, fig.width=14, fig.height=7}
# Préparer les blocs
blocks <- list(
  RNA = rna_scaled,
  Protein = prot_scaled,
  Cytokine = cyto_scaled
)

# sPCA multi-blocs non supervisée
spca_res <- block.sparse.pca(
  X = blocks,
  ncomp = 2,   # nombre de composantes
  keepX = list(
    RNA = c(10, 5),       # 10 features sur comp1, 5 sur comp2
    Protein = c(10, 5),
    Cytokine = c(10, 5)
  ),
  scale = TRUE
)

# Visualiser les échantillons (non supervisée, pas de Y)
plotIndiv(spca_res, legend = TRUE, ellipse = TRUE, title = "sPCA multi-blocs")

# Extraire les variables retenues
selected_vars <- lapply(names(blocks), function(bloc) {
  lapply(1:2, function(comp) {
    sv <- selectVar(spca_res, block = bloc, comp = comp)
    sv[[bloc]]$name   # noms des variables
  })
})
names(selected_vars) <- names(blocks)

# Affichage
selected_vars
```

**Commentaire :**

L'analyse sPCA sur les trois blocs RNA, protein et cytokyne met en évidence les gènes, protéines et cytokines les plus discriminantes entre les classes IR et IS.

-   Concernant le bloc RNA, parmi les 10 features sélectionnées sur PC1, on retrouve des gènes impliqués dans la régulation énergétique (donc liés à la réponse métabolique à l'insuline et au glucose, comme *PRKAB1*). On retrouve aussi des gènes impliqués dans la méthylation et la stabilité de l'ARN (comme *METTL14* dont l'implication a été décrite dans la sensibilité à l'insuline), et des gènes impliqués dans la signalisation inflammatoire ou structurelle (comme *CEACAM6*, souvent surexprimé dans un contexte inflammatoire et métabolique).

    La deuxième composante PC2 semble capturer des différences plus subtiles liées à la régulation transcriptionnelle et épigénétique, à la dynamique du cytosquelette et au contrôle de la traduction, complétant ainsi l’information de PC1 sur le métabolisme énergétique et la signalisation cellulaire.

-   Concernant le bloc protein, PC1 capture majoritairement des axes liés à l’inflammation, la réponse immunitaire et le métabolisme lipidique (métabolisme des triglycérides), avec un mélange de protéines plasmatiques impliquées dans la coagulation (Fibrinogène, Plasminogène), et la régulation du complément. Ces variations peuvent refléter les différences entre les groupes IS et IR au niveau du profil protéique circulant et de la réponse inflammatoire.

    PC2 semble capter un axe métabolique et hormonal, avec des protéines liées au transport du fer (Transferrine), lipides (Apolipoprotéines), régulation hormonale et coagulation (Prothrombine). Ces variations permettent de distinguer les classes IS/IR selon des variations moins directement inflammatoires mais plus liées au métabolisme et au stress physiologique.

-   Concernant le bloc cytokyne, PC1 capture un axe inflammatoire et angiogénique. Les features sélectionnés sont principalement liés à : l'inflammation et recrutement cellulaire (MCP1, EOTAXIN, ICAM1, ENA78, IL17A/F), et l'angiogenèse et régénération tissulaire (VEGF, VEGFD, PDGFBB, EGF). Cela suggère que la première composante reflète la variabilité des réponses immunes et vasculaires entre les classes IS et IR.

    PC2 semble capturer un axe métabolique et immunitaire orienté Th2 (lymphocytes TCD4+ impliqués dans la réponse anti-parasitaire et humorale) / activation cellulaire : cytokines liées à l’inflammation et activation des leucocytes (GM-CSF, RANTES, RESISTIN), et cytokines orientées réponse adaptative et métabolique (IL4, LEPTIN).

**Identifier le bloc le plus informatif :**

```{r, fig.width=14, fig.height=7}
lapply(spca_res$loadings, function(x) apply(abs(x), 2, mean))

cor(spca_res$variates$RNA[,1], spca_res$variates$Protein[,1])
cor(spca_res$variates$RNA[,1], spca_res$variates$Cytokine[,1])
cor(spca_res$variates$Protein[,1], spca_res$variates$Cytokine[,1])

plotArrow(spca_res, title = "Contribution des blocs")
```

```{r, fig.width=14, fig.height=7}
circosPlot(spca_res, comp = 1, cutoff = 0.5, line = TRUE)
```

Les valeurs ci-dessus correspondent aux corrélations entre chaque bloc et la variable Y (les classes IS et IR), sur chaque composante. Le bloc cytokyne est le plus informatif des 3 blocs (0.098/0.064).

Les valeurs pour \$Y et les corrélations globales (\~0.92–0.95) montre que la sPCA capte bien la structure globale, mais le signal le plus discriminant vient surtout des cytokines.

# **5. Analyse supervisée**

```{r, fig.width=14, fig.height=7}
# Récupérer toutes les features sélectionnées
selected_rna <- unlist(selected_vars$RNA)
selected_prot <- unlist(selected_vars$Protein)
selected_cyto <- unlist(selected_vars$Cytokine)

# Concaténer les blocs en ne gardant que les features sélectionnées
X_sel <- cbind(
  rna_scaled[, selected_rna, drop = FALSE],
  prot_scaled[, selected_prot, drop = FALSE],
  cyto_scaled[, selected_cyto, drop = FALSE]
)

# Y = classe IS / IR
Y <- factor(data_t2d$sample_info$mode)

# PLS-DA supervisée
plsda_res <- splsda(X_sel, Y, ncomp = 2)

# Visualiser les échantillons avec ellipses
plotIndiv(
  plsda_res,
  group = Y,
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS-DA multi-blocs (features sélectionnées)"
)
```

```{r}
# Validation croisée
set.seed(123)  # pour reproductibilité
perf_res <- perf(plsda_res,
                 validation = "Mfold",  # k-fold CV
                 folds = 5,             # 5 folds
                 progressBar = TRUE,
                 nrepeat = 10)          # répéter 10 fois

# Erreur de classification globale
perf_res$error.rate$overall

# Balanced Error Rate (si classes déséquilibrées)
perf_res$error.rate$BER

# Visualiser la performance par composante
perf_res$choice.ncomp
```

```{r, fig.width=14, fig.height=7}
# Sélection des variables contributives par bloc et composante
selected_vars_plsda <- lapply(names(blocks), function(bloc) {
  lapply(1:2, function(comp) {
    sv <- selectVar(spca_res, block = bloc, comp = comp)
    sv[[bloc]]$name
  })
})
names(selected_vars_plsda) <- names(blocks)

# Affichage pour chaque bloc
selected_vars_plsda

# Visualiser la contribution des variables sur PC1 et PC2 (exemple pour RNA)
plotVar(plsda_res, block = "RNA - protein - cytokyne", comp = 1:2, var.names = TRUE, title = "Contributions RNA PC1/PC2")
```

**Commentaire :** Pour évaluer la capacité des blocs omiques (RNA, protéines, cytokines) à discriminer les classes IS et IR, nous avons réalisé une PLS-DA sur les blocs concaténés, en utilisant les features sélectionnées par la sPCA.

Le graphique des échantillons montre deux ellipses bien séparées correspondant aux classes IS et IR, sans chevauchement notable. La dispersion intra-groupe est faible, ce qui indique une homogénéité des échantillons au sein de chaque classe. La cross-validation confirme cette observation, avec un taux d’erreur global très faible, indiquant une excellente performance de classification.

Ces résultats suggèrent que la combinaison multi-blocs, en particulier avec les features sélectionnées par la sPCA, capture efficacement la variabilité pertinente entre les groupes et permet de distinguer clairement IS et IR. Cette approche multi-omique est donc plus discriminante que la PCA réalisée bloc par bloc, où certaines ellipses étaient plus étalées ou se chevauchaient.

# **6. Analyse d'intégration**

## *a. PLS*

```{r, fig.width=40, fig.height=20}
# -----------------------------
# Blocs à inclure
# -----------------------------
X_block <- rna_scaled       # matrice RNA
Y_block <- prot_scaled      # matrice Protein

# PLS classique (X → Y)
pls_res <- pls(X_block, Y_block, ncomp = 10, scale = TRUE)

# Y = classe IS / IR
Y <- factor(data_t2d$sample_info$mode)

# -----------------------------
# Visualisation des individus dans l'espace X (RNA)
# -----------------------------
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,               # classe IR / IS pour colorer
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

# -----------------------------
# Visualisation des variables (loadings) - Top 20 par composante
# -----------------------------

# Extraire les loadings X (RNA) et Y (Protein)
loadings_X <- pls_res$loadings$X
loadings_Y <- pls_res$loadings$Y

# Fonction pour récupérer les top N variables par composante
get_topN <- function(loadings, N = 20) {
  df_list <- lapply(1:ncol(loadings), function(comp) {
    df <- data.frame(
      Nom = rownames(loadings),
      Loading = loadings[, comp],
      Composante = paste0("Comp", comp),
      stringsAsFactors = FALSE
    )
    df %>% slice_max(order_by = abs(Loading), n = N)
  })
  bind_rows(df_list)
}

topX <- get_topN(loadings_X, N = 20)
topY <- get_topN(loadings_Y, N = 20)

# Ajouter une colonne Bloc pour couleur
topX$Bloc <- "RNA"
topY$Bloc <- "Protein"

top_vars <- bind_rows(topX, topY)

# Plot avec ggplot
ggplot(top_vars, aes(x = reorder(Nom, Loading), y = Loading, fill = Bloc)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Composante, scales = "free") +
  coord_flip() +
  theme_bw() +
  labs(
    title = "Top 20 variables contributives PLS RNA → Protein",
    x = "",
    y = "Loading"
  ) +
  scale_fill_manual(values = c("RNA" = "steelblue", "Protein" = "coral"))
```

```{r, fig.width=14, fig.height=7}
# -----------------------------
# Blocs à inclure
# -----------------------------
X_block <- rna_scaled       # matrice RNA
Y_block <- prot_scaled      # matrice Protein
Y <- factor(data_t2d$sample_info$mode)  # IS / IR

# -----------------------------
# PLS classique
# -----------------------------
pls_res <- pls(
  X_block, Y_block,
  ncomp = 10,   # deux composantes principales pour visualisation
  scale = TRUE
)

# -----------------------------
# Visualisation des individus (scores)
# -----------------------------
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

# -----------------------------
# Top 20 variables contributives par composante
# -----------------------------
top_vars_list <- list()

for (bloc in c("X", "Y")) {
  ncomp_bloc <- if(bloc == "X") ncol(pls_res$loadings$X) else ncol(pls_res$loadings$Y)
  
  for (comp in 1:ncomp_bloc) {
    sv <- if(bloc == "X") {
      data.frame(
        Nom = rownames(pls_res$loadings$X),
        Loading = pls_res$loadings$X[, comp],
        stringsAsFactors = FALSE
      )
    } else {
      data.frame(
        Nom = rownames(pls_res$loadings$Y),
        Loading = pls_res$loadings$Y[, comp],
        stringsAsFactors = FALSE
      )
    }
    
    df <- sv %>%
      dplyr::mutate(
        Bloc = ifelse(bloc == "X", "RNA", "Protein"),
        Composante = paste0("Comp", comp)
      ) %>%
      dplyr::arrange(desc(abs(Loading))) %>%
      dplyr::slice(1:20)  # top 20
    top_vars_list[[paste0(bloc, "_Comp", comp)]] <- df
  }
}

# Fusionner tous les blocs/composantes
top_vars_pls_df <- bind_rows(top_vars_list)

# Tableau des top 20 variables
knitr::kable(top_vars_pls_df, digits = 3, caption = "Top 20 variables contributives PLS RNA → Protein")

# -----------------------------
# Détermination du nombre optimal de composantes via variance expliquée
# -----------------------------
# Variance expliquée pour X et Y
var_expl_X <- pls_res$prop_expl_var$X
var_expl_Y <- pls_res$prop_expl_var$Y

# Graphique variance expliquée cumulée
par(mfrow = c(1,2))
plot(var_expl_X, type = "b", pch = 19, col = "steelblue",
     xlab = "Composante", ylab = "Variance expliquée (%)",
     main = "Variance expliquée - RNA (X)")
abline(h = 0.05, col = "red", lty = 2)

plot(var_expl_Y, type = "b", pch = 19, col = "darkgreen",
     xlab = "Composante", ylab = "Variance expliquée (%)",
     main = "Variance expliquée - Protein (Y)")
abline(h = 0.05, col = "red", lty = 2)
par(mfrow = c(1,1))
```

```{r, fig.width=14, fig.height=7}
# Variance expliquée par composante
var_expl_X <- pls_res$prop_expl_var$X
var_expl_Y <- pls_res$prop_expl_var$Y

# Préparer les deux datasets pour ggplot
df_var <- data.frame(
  Composante = rep(1:length(var_expl_X), 2),
  Variance = c(var_expl_X, var_expl_Y),
  Bloc = rep(c("RNA (X)", "Protein (Y)"), each = length(var_expl_X))
)

# Elbow plot
ggplot(df_var, aes(x = Composante, y = Variance, color = Bloc)) +
  geom_point(size = 3) +
  geom_line(size = 1) +
  geom_vline(xintercept = 2, linetype = "dashed", color = "red") +  # composante optimale
  theme_minimal() +
  labs(
    title = "Elbow plot - PLS RNA → Protein",
    x = "Composante",
    y = "Variance expliquée",
    color = "Bloc"
  ) +
  scale_color_manual(values = c("steelblue", "darkgreen"))
```

```{r, fig.width=40, fig.height=20}
# Graphique des individus (scores)
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

get_top20 <- function(loadings, bloc_name){
  df <- as.data.frame(loadings)
  df$Nom <- rownames(df)
  df_long <- pivot_longer(df, cols = starts_with("Comp"), names_to = "Composante", values_to = "Loading")
  df_long <- df_long %>%
    group_by(Composante) %>%
    slice_max(order_by = abs(Loading), n = 20) %>%
    ungroup() %>%
    mutate(Bloc = bloc_name)
  return(df_long)
}

top20_X <- get_top20(pls_res$loadings$X, "RNA")
top20_Y <- get_top20(pls_res$loadings$Y, "Protein")

top20_all <- bind_rows(top20_X, top20_Y)

# -----------------------------
# Barplot ggplot2
# -----------------------------
ggplot(top20_all, aes(x = reorder(Nom, Loading), y = Loading, fill = Bloc)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Composante, scales = "free_y") +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Top 20 variables contributives PLS RNA → Protein",
    x = "Variable",
    y = "Loading"
  ) +
  scale_fill_manual(values = c("RNA" = "steelblue", "Protein" = "darkgreen"))

# Arrow plot (correlation circle)
plotArrow(pls_res,
          comp = c(1,2),
          group = Y,
          var.names = TRUE,
          title = "PLS RNA → Protein - arrow plot")
```

```{r}
# Scores des composantes
scores_X <- pls_res$variates$X
scores_Y <- pls_res$variates$Y

# Corrélation des composantes correspondantes
cor_comp1 <- cor(scores_X[,1], scores_Y[,1])
cor_comp2 <- cor(scores_X[,2], scores_Y[,2])

cor_comp1
cor_comp2
```

**Commentaire :**

*- Composante 1* (cor = 0.88) : forte corrélation entre la première composante RNA et Protein. Cela signifie que les variations transcriptomiques capturent bien la variation protéique. Les gènes les plus contributifs de cette composante sont donc de bons candidats pour expliquer la variation des protéines.

*- Composante 2* (cor = 0.96) : corrélation encore plus forte. Même les signaux secondaires sont très concordants entre RNA et Protein. Cela montre que les deux blocs sont très alignés, et que la structure globale du transcriptome se reflète dans le protéome.

La PLS révèle une forte cohérence entre les profils RNA et protéine dans ce jeu de données. Les gènes et protéines les plus contributifs des composantes 1 et 2 sont des biomarqueurs potentiels pour différencier les groupes IR vs IS.

## *b. sPLS*

```{r, fig.width=14, fig.height=7}
# -----------------------------
# 1. Définir les blocs
# -----------------------------
library(fastDummies)

# Blocks X
blocks <- list(
  RNA = rna_scaled,
  Protein = prot_scaled,
  Cytokine = cyto_scaled
)

# Bloc réponse : facteur → matrice binaire
Y_block <- fastDummies::dummy_cols(
  data.frame(mode = data_t2d$sample_info$mode),
  select_columns = "mode",
  remove_first_dummy = FALSE,
  remove_selected_columns = TRUE
)
Y_block <- as.matrix(Y_block)

rownames(Y_block) <- rownames(blocks$RNA)

# sPLS multi-blocs supervisée
spls_res <- block.spls(
  X = blocks,
  Y = Y_block,
  ncomp = 2,
  keepX = list(
    RNA = c(10, 5),
    Protein = c(10, 5),
    Cytokine = c(5, 5)
  ),
  scale = TRUE
)

# -----------------------------
# 2. Graphiques
# -----------------------------

# Individus (scores)
plotIndiv(
  spls_res,
  comp = c(1,2),
  group = factor(data_t2d$sample_info$mode),
  legend = TRUE,
  ellipse = TRUE,
  title = "sPLS multi-blocs - individus"
)

# Variables (loadings) - plots séparés
for(bloc_name in names(blocks)){
  plotVar(
    spls_res,
    comp = 1:2,
    block = bloc_name,
    var.names = TRUE,
    title = paste0("sPLS - Variables ", bloc_name)
  )
}

# Arrow plot global
plotArrow(
  spls_res,
  comp = 1:2,
  group = factor(data_t2d$sample_info$mode),
  var.names = TRUE,
  title = "sPLS multi-blocs - arrow plot"
)

# -----------------------------
# 3. Variables retenues par bloc et composante
# -----------------------------
selected_vars_spls <- list()

for(bloc_name in names(blocks)){
  selected_vars_spls[[bloc_name]] <- list()
  ncomp_bloc <- ncol(spls_res$loadings[[bloc_name]])
  
  for(comp in 1:ncomp_bloc){
    loadings <- spls_res$loadings[[bloc_name]][, comp, drop = FALSE]
    selected_vars_spls[[bloc_name]][[comp]] <- rownames(loadings)[abs(loadings) > 0]
  }
}

selected_vars_spls

# -----------------------------
# 4. Optionnel : top variables en barplot ggplot2 par bloc
# -----------------------------
top_vars_list <- list()
for(bloc_name in names(selected_vars_spls)){
  for(comp in seq_along(selected_vars_spls[[bloc_name]])){
    vars <- selected_vars_spls[[bloc_name]][[comp]]
    loadings <- spls_res$loadings[[bloc_name]][vars, comp]
    df <- data.frame(
      Nom = vars,
      Loading = loadings,
      Bloc = bloc_name,
      Composante = paste0("Comp", comp),
      stringsAsFactors = FALSE
    )
    top_vars_list[[paste0(bloc_name, "_Comp", comp)]] <- df
  }
}

top_vars_df <- bind_rows(top_vars_list)

ggplot(top_vars_df, aes(x = reorder(Nom, Loading), y = Loading, fill = Bloc)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Composante, scales = "free_y") +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Top variables contributives sPLS par bloc",
    x = "Variable",
    y = "Loading"
  ) +
  scale_fill_manual(values = c("RNA" = "steelblue", "Protein" = "darkgreen", "Cytokine" = "orange"))

```

**Commentaire :**

-   Concernant le bloc RNA, PC1 regroupe les gènes qui traduisent la variation principale du transcriptome, et qui se reflète dans le protéome et la cytokine : prolifération, apoptose, modifications post-transcriptionnelles. Ce sont donc des candidats clés pour expliquer la différence IR vs IS.

PC2 capture un signal secondaire, moins dominant que PC1 mais toujours cohérent avec la régulation post-transcriptionnelle et le trafficking des protéines.

-   Concernant le bloc protein, PC1 regroupe des protéines impliquées dans l’inflammation, la coagulation et l’activation du complément. Ces variations reflètent probablement la différence entre les profils circulants IS et IR, avec un accent sur les réponses immunitaires et inflammatoires.

PC2 semble capter un axe plus métabolique et hormonal, moins directement inflammatoire. On retrouve des protéines qui peuvent être impliquées dans le transport de facteurs circulants, le métabolisme lipidique ou la régulation hormonale. Cela complète l’information de PC1 en distinguant les groupes selon des variations métaboliques et physiologiques moins liées à l’inflammation.

-   Concernant le bloc cytokyne, PC1 met en évidence un axe fortement inflammatoire et angiogénique. Les cytokines les plus contributives incluent EOTAXIN et MCP1, qui sont impliquées dans le recrutement des éosinophiles et des monocytes/macrophages, respectivement, suggérant une activation marquée des réponses immunitaires innées. Les facteurs de croissance et d’angiogenèse tels que VEGFD, EGF et PDGFBB apparaissent également parmi les features les plus discriminantes, indiquant que cette composante reflète non seulement la variabilité des réponses inflammatoires mais aussi l’état du remodelage vasculaire et de la régénération tissulaire. En résumé, PC1 semble représenter un profil global combinant inflammation, recrutement cellulaire et potentiel angiogénique, qui distingue clairement les individus IR des individus IS.

PC2 capture des variations plus subtiles mais biologiquement significatives, orientées vers la régulation immunitaire adaptative et l’interaction métabolisme‑immunité. On y retrouve IL4, cytokine clé de la polarisation Th2 et de la réponse humorale, et IL17A, impliquée dans l’inflammation et l’activation des leucocytes. GM-CSF est également contributive, reflétant l’activation et la prolifération des cellules myéloïdes, tandis que LEPTIN introduit une dimension métabolique, liant l’état énergétique à la modulation immunitaire. Enfin, ENA78 souligne la composante inflammatoire liée au recrutement des neutrophiles. Cette composante semble donc représenter un axe de coordination entre l’immunité adaptative, l’activation cellulaire et la régulation métabolique, complétant l’information fournie par PC1 sur les différences IR vs IS.

## *c. Analyse d'enrichissement*

```{r, fig.width=14, fig.height=7}
# -----------------------------
# 1. Extraire les top variables du PLS RNA→Protein
# -----------------------------
# Top 50 par bloc, composante 1
top_genes_rna <- rownames(pls_res$loadings$X)[order(abs(pls_res$loadings$X[,1]), decreasing = TRUE)[1:50]]
top_genes_prot <- rownames(pls_res$loadings$Y)[order(abs(pls_res$loadings$Y[,1]), decreasing = TRUE)[1:50]]

# -----------------------------
# 2. Convertir les identifiants en SYMBOL humains
# RNA : ENSEMBL → SYMBOL
rna_map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = top_genes_rna,
  keytype = "ENSEMBL",
  columns = c("SYMBOL")
)

# Protein : UNIPROT → SYMBOL
prot_map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = top_genes_prot,
  keytype = "UNIPROT",
  columns = c("SYMBOL")
)

# Combiner tous les SYMBOLs et retirer NA
top_genes_symbol <- unique(c(rna_map$SYMBOL, prot_map$SYMBOL))
top_genes_symbol <- top_genes_symbol[!is.na(top_genes_symbol)]

# Vérification
print(top_genes_symbol)

# -----------------------------
# 3. Analyse d'enrichissement GO/Reactome
# -----------------------------
if(length(top_genes_symbol) > 0){
  gost_res <- gost(
    query = top_genes_symbol,
    organism = "hsapiens",
    sources = c("GO:BP", "REAC"),
    significant = TRUE,          # filtrer les termes significatifs
    correction_method = "fdr"
  )
  
  # -----------------------------
  # 4. Vérification des résultats
  # -----------------------------
  if(!is.null(gost_res$result) && nrow(gost_res$result) > 0){
    
    # Top 10 termes enrichis par p-value
    top10 <- gost_res$result %>%
      arrange(p_value) %>%
      slice_head(n = 10)
    
    # Barplot
    ggplot(top10, aes(x = reorder(term_name, -log10(p_value)),
                      y = -log10(p_value),
                      fill = source)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      labs(x = "Pathway / GO term",
           y = "-log10(p-value)",
           title = "Enrichissement GO (BP) / Reactome - Top 10") +
      theme_minimal()
    
  } else {
    message("Aucun terme enrichi trouvé pour ces gènes/protéines.")
  }
  
} else {
  message("Aucun gène convertible en SYMBOL humain trouvé. Vérifie tes identifiants.")
}
```

**Commentaire :** L’analyse d’enrichissement GO/Reactome des gènes et protéines les plus discriminants (issus de la PLS RNA→Protein) met en évidence une surreprésentation de processus liés à la réponse inflammatoire, au métabolisme lipidique et au transport du fer, ainsi qu’à des voies de signalisation hormonale et de stress oxydatif. Ces voies sont cohérentes avec les différences physiopathologiques attendues entre les sujets IR et IS, notamment l’activation de la réponse immune innée et les perturbations du métabolisme énergétique.

Ces résultats sont cohérents avec ceux obtenus lors des analyses précédentes.

## *d. DIABLO*

```{r}
Y <- factor(data_t2d$sample_info$mode)
X <- list(
  RNA = rna_scaled,
  Protein = prot_scaled,
  Cytokine = cyto_scaled
)



# aligner les lignes sur les échantillons
for (b in names(X)) rownames(X[[b]]) <- rownames(data_t2d$sample_info)



lapply(X, dim)

```

```{r}
design = matrix(0.1, ncol = length(X), nrow = length(X), 
                dimnames = list(names(X), names(X)))
diag(design) = 0 # set diagonal to 0s

design
```

```{r}
basic.diablo.model <- block.splsda(
  X = X, Y = Y,
  ncomp = 5,
  design = design,
  near.zero.var = TRUE
)

perf.diablo = perf(basic.diablo.model, validation = 'Mfold', 
                   folds = 3, nrepeat = 10, progressBar = TRUE) 

plot(perf.diablo) # plot output of tuning
```

```{r}
ncomp = perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "centroids.dist"] 
perf.diablo$choice.ncomp$WeightedVote 
```

```{r}
test.keepX <- list(
  RNA = c(50, 100, 200, 500, 800),
  Protein = c(5, 10, 20, 30, 50),
  Cytokine = c(3, 5, 10, 15, 20)
)


tune.TCGA = tune.block.splsda(X = X, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design,
                              validation = 'Mfold', folds = 3, nrepeat = 5,
                              dist = "centroids.dist", progressBar = TRUE)
```

```{r}
list.keepX = tune.TCGA$choice.keepX
list.keepX
```

```{r}
# set the optimised DIABLO model
final.diablo.model = block.splsda(X = X, Y = Y, ncomp = ncomp, 
                          keepX = list.keepX, design = design)
```

```{r,  fig.width=14, fig.height=7}
# Nombre de composantes par bloc
ncomp_max <- min(sapply(final.diablo.model$variates, ncol))

# Boucle pour plotDiablo sur toutes les composantes
for (comp in 1:ncomp_max) {
  plotDiablo(final.diablo.model, ncomp = comp, 
             title = paste("DIABLO - Composante", comp))
}
```

```{r, fig.width=14, fig.height=7}
plotIndiv(final.diablo.model, ind.names = FALSE, legend = TRUE, 
          title = 'DIABLO Sample Plots')
```

```{r, fig.width=14, fig.height=7}
plotArrow(final.diablo.model, ind.names = FALSE, legend = TRUE, 
          title = 'DIABLO')
```

```{r, fig.width=14, fig.height=7}
plotVar(final.diablo.model, var.names = FALSE, 
        style = 'graphics', legend = TRUE,
        pch = c(16, 17, 15), cex = c(2,2,2), 
        col = c('darkorchid', 'brown1', 'lightgreen'))
```

```{r, fig.width=14, fig.height=7}
circosPlot(final.diablo.model, cutoff = 0.7, line = TRUE,
           color.blocks= c('darkorchid', 'brown1', 'lightgreen'),
           color.cor = c("chocolate3","grey20"), size.labels = 1.5)
```

```{r fig.width=14, fig.height=7}
network(final.diablo.model, blocks = c(1,2,3),
        color.node = c('darkorchid', 'brown1', 'lightgreen'), cutoff = 0.78)
```

# **7. Analyse en réseau**

## *a. Réseau de régulation génique (GRN)*

```{r, fig.width=14, fig.height=7}
# 1. Filtrer et scaler RNA (adapte le seuil CV si besoin)
rna_keep <- !is.na(cv_rna) & cv_rna >= 1.5
rna_filt <- rna_mat[, rna_keep, drop = FALSE]
rna_scaled <- scale(rna_filt)

# 2. Construire la matrice d'information mutuelle et CLR
mi <- build.mim(rna_scaled, estimator = "spearman")
clr_mat <- clr(mi)

# 3. Seuil pour garder les liens les plus forts
thr <- quantile(clr_mat[clr_mat > 0], 0.95)
clr_mat[clr_mat < thr] <- 0
diag(clr_mat) <- 0

# 4. Créer le GRN comme objet igraph
g_grn <- graph_from_adjacency_matrix(clr_mat, mode = "undirected", weighted = TRUE, diag = FALSE)

# 5. Statistiques
nb_noeuds <- vcount(g_grn)
nb_aretes <- ecount(g_grn)
degre <- degree(g_grn)
isoles_idx <- which(degre == 0)
hub_gene <- names(which.max(degre))
hub_deg <- max(degre)

cat("Nombre de nœuds :", nb_noeuds, "\n")
cat("Nombre d'arêtes :", nb_aretes, "\n")
cat("Nombre de nœuds isolés :", length(isoles_idx), "\n")
cat("Gène le plus connecté :", hub_gene, "avec", hub_deg, "connexions\n")

# 6. Histogramme des degrés
hist(degre, breaks = 50, main = "Distribution des degrés", xlab = "Degré", ylab = "Fréquence")
```

**Commentaire :**

On trouve pour ce réseau : 859 noeuds (gènes présents dans le sous-réseau), 6603 arètes (119 interactions entre elles), aucun noeud isolé (gène n'ayant aucune interaction dans le réseau). Le gène le plus connecté est ENSG00000044459 (correpond au gène *CNTLN* codant pour une protéine impliquée dans l’organisation du centrosome et du cytosquelette), qui est connectée à 30 autres gènes.

## *b. Réseau d’interactions protéiques (PPI)*

```{r, fig.width=14, fig.height=7}
BioGRID <- readRDS("/Users/roxanedesvilles/Documents/Pharmacie P5 DESCARTES/6A - M2 Bioinformatique biologique (UPc) 2025-2026/S1/UE Bioinformatique des omiques avancées/UE 8 - Production et gestion des big data en biologie/tp-multiomics/human_ppi.Rds")
str(BioGRID)
prot_ids <- colnames(prot_scaled)
ppi_edges <- subset(BioGRID, A %in% prot_ids & B %in% prot_ids)

g_ppi <- graph_from_data_frame(ppi_edges, directed = FALSE, vertices = data.frame(name = prot_ids))

nb_noeuds   <- vcount(g_ppi)
nb_aretes   <- ecount(g_ppi)
degre       <- degree(g_ppi)
isoles_idx  <- which(degre == 0)
hub_prot    <- names(which.max(degre))
hub_deg     <- max(degre)

list(
  noeuds = nb_noeuds,
  aretes = nb_aretes,
  nb_isoles = length(isoles_idx),
  proteine_hub = hub_prot,
  connexions_hub = hub_deg
)

hist(degre, breaks = 50, main = "Distribution des degrés (PPI)", xlab = "Degré", ylab = "Fréquence")
```

**Commentaire :**

On trouve pour ce réseau : 163 noeuds (protéines présentes dans le sous-réseau), 119 arètes (119 interactions entre elles), 88 noeuds isolés (protéines n'ayant aucune interaction dans le réseau). La protéine la plus connectée est P02647 (correspond à l'Apolipoprotéine A1 humaine), qui est connectée à 19 autres protéines.

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)

genes <- colnames(rna_scaled_bis)
prots <- colnames(prot_scaled)

map <- AnnotationDbi::select(org.Hs.eg.db, keys = genes,
                             keytype = "ENSEMBL", columns = c("SYMBOL","UNIPROT"))
map <- na.omit(unique(map[c("ENSEMBL","UNIPROT")]))


gp_edges <- subset(map, UNIPROT %in% prots)
colnames(gp_edges) <- c("gene","protein")  # ENSEMBL, UNIPROT
```

```{r}
tfdb <- readRDS("/Users/roxanedesvilles/Documents/Pharmacie P5 DESCARTES/6A - M2 Bioinformatique biologique (UPc) 2025-2026/S1/UE Bioinformatique des omiques avancées/UE 8 - Production et gestion des big data en biologie/tp-multiomics/human_TF_to_targeted_gene.Rds")

tf_edges <- tfdb

colnames(tf_edges) <- c("tf", "gene")

genes <- colnames(rna_scaled_bis)
tf_edges <- subset(tf_edges, gene %in% genes)


prots <- colnames(prot_scaled)
tf_edges <- subset(tf_edges, tf %in% prots | !(tf %in% prots))

head(tf_edges)
dim(tf_edges)
```

```{r}
tf_df <- data.frame(from = tf_edges$tf, to = tf_edges$gene, type = "TF", directed = TRUE)
g_tf <- graph_from_data_frame(tf_df, directed = TRUE)

vcount(g_tf)   # nombre total de nœuds (TF + gènes)
ecount(g_tf)   # nombre d'arêtes TF→gène

```

```{r, fig.width=14, fig.height=7}
set.seed(1234)
plot(
  g_tf,
  vertex.size = 3,
  vertex.label = NA,
  edge.arrow.size = 0.3,
  main = "Réseau TF → gène"
)
```

## *c. Connexion gène–protéine*

### c.1. Connexion

```{r}
genes <- V(g_grn)$name
proteins <- V(g_ppi)$name


gene_coding_prot <- readRDS("/Users/roxanedesvilles/Documents/Pharmacie P5 DESCARTES/6A - M2 Bioinformatique biologique (UPc) 2025-2026/S1/UE Bioinformatique des omiques avancées/UE 8 - Production et gestion des big data en biologie/tp-multiomics/human_gene_to_coding_protein.Rds")
prot_tf_gene <- readRDS("/Users/roxanedesvilles/Documents/Pharmacie P5 DESCARTES/6A - M2 Bioinformatique biologique (UPc) 2025-2026/S1/UE Bioinformatique des omiques avancées/UE 8 - Production et gestion des big data en biologie/tp-multiomics/human_TF_to_targeted_gene.Rds")


names(gene_coding_prot) <- c("gene_id", "protein_id")
names(prot_tf_gene)     <- c("protein_id", "gene_id")
```

```{r}
E_gene_prot <- gene_coding_prot %>%
  filter(gene_id %in% genes, protein_id %in% proteins) %>%
  transmute(from = gene_id, to = protein_id, type = "gene_to_protein")


E_tf_gene <- prot_tf_gene %>%
  filter(protein_id %in% proteins, gene_id %in% genes) %>%
  transmute(from = protein_id, to = gene_id, type = "TF_to_gene")
```

```{r}
g_comb <- disjoint_union(g_grn, g_ppi)

E_cross <- bind_rows(E_gene_prot, E_tf_gene)
g_comb <- g_comb + edges(as.vector(t(E_cross[, c("from", "to")])), type = E_cross$type)
```

```{r}
res <- list(
  noeuds_total    = vcount(g_comb),
  aretes_total    = ecount(g_comb),
  aretes_cross    = nrow(E_cross),
  n_gene_to_prot  = nrow(E_gene_prot),
  n_TF_to_gene    = nrow(E_tf_gene)
)
res
```

### c.2. Analyse de modularité

```{r}
# Convertir le graphe en non orienté proprement
g_comb_u <- as.undirected(g_comb, mode = "collapse")

# Vérif si un attribut weight existe
if ("weight" %in% edge_attr_names(g_comb_u)) {
  # Supprimer les NA ou les remplacer par 1
  E(g_comb_u)$weight[is.na(E(g_comb_u)$weight)] <- 1
} else {
  # S'il n'y a pas de poids, on en crée un uniforme
  E(g_comb_u)$weight <- 1
}

# Supprimer les self-loops et éventuelles anomalies
g_comb_u <- simplify(g_comb_u, remove.loops = TRUE, remove.multiple = TRUE)

# Louvain
communities <- cluster_louvain(g_comb_u)

# Résumé
modularity_value <- modularity(communities)
n_modules <- length(unique(membership(communities)))
module_sizes <- sizes(communities)

cat("Nombre de modules :", n_modules, "\n")
cat("Modularité globale :", round(modularity_value, 3), "\n")
head(sort(module_sizes, decreasing = TRUE))
```

**Commentaire :**

114 modules → donc ton réseau combiné (gène–protéine–TF) est assez modulaire, avec beaucoup de sous-groupes cohérents biologiquement.

Modularité = 0.684 → c’est élevé → ton graphe est fortement structuré (claire séparation entre modules).

Les plus gros modules (de 90 à 120 nœuds) sont sans doute les principaux complexes ou voies biologiques.

### c.3. Choix du noeud d'intérêt et random walk

```{r}
V(g_comb_u)$module <- membership(communities)

set.seed(42)
ggraph(g_comb_u, layout = "fr") +
  geom_edge_link(alpha = 0.1) +
  geom_node_point(aes(color = as.factor(module)), size = 2) +
  theme_void() +
  ggtitle("Modules du réseau combiné (gène–protéine–TF)")
```

```{r}
# identifier un hub
deg <- degree(g_comb_u)
head(sort(deg, decreasing = TRUE), 10)
```

```{r}
mapIds(org.Hs.eg.db, keys = "P06733", keytype = "UNIPROT", column = "SYMBOL")
```

### c.4. Random Walk (RW)

**Commentaire :**

Nous avons choisi P06733 (ENO1) comme nœud de départ pour la Random Walk with Restart (RWR) pour trois raisons complémentaires :

-Topologie — ENO1 est le nœud le plus connecté du réseau combiné (degré = 751), donc il agit comme un hub topologique et peut relier plusieurs modules fonctionnels. Étudier sa diffusion informe sur les régions du réseau qui dépendent ou s’organisent autour de ce hub.

-Biologie — ENO1 codant pour l’alpha-énolase, joue un rôle central en glycolyse et possède des fonctions additionnelles (interaction plasminogène, implication dans signalisation/prolifération cellulaire) : il est donc plausible qu’il connecte des modules métabolique, protéique et régulateur.

-Methodologie — partir d’un hub maximise la sensibilité du RWR pour détecter sous-réseaux fortement reliés et met en évidence des modules potentiellement fonctionnels liés au métabolisme et à la régulation cellulaire.

```{r}
# --- paramètres RWR ---
seed_node <- "P06733"   # ENO1
restart_prob <- 0.85    # probabilité de rester au seed (typiquement 0.7-0.85)
tol <- 1e-6
max_iter <- 500
```

```{r}
# Graphe pour RWR : utiliser g_comb_u (non dirigé) ou g_comb selon ta méthodo
g_rw <- as.undirected(g_comb, mode = "collapse")
A <- as_adjacency_matrix(g_rw, attr = NULL, sparse = FALSE)  # ignorons poids si pb
# normaliser lignes (transition matrix)
row_sums <- rowSums(A)
row_sums[row_sums == 0] <- 1
Pmat <- A / row_sums
```

```{r}
# vecteur initial
n <- vcount(g_rw)
p0 <- numeric(n)
names(p0) <- V(g_rw)$name
p0[seed_node] <- 1
```

```{r}
# RWR itératif (power-iteration)
p <- p0
for (i in 1:max_iter) {
  p_new <- (1 - restart_prob) * p0 + restart_prob * (Pmat %*% p)
  if (max(abs(p_new - p)) < tol) break
  p <- p_new
}
scores <- as.numeric(p)
names(scores) <- V(g_rw)$name
scores <- sort(scores, decreasing = TRUE)
```

```{r}
# Top résultats
top10 <- head(scores, 20)
print(top10)
```

```{r}
# Module du seed
V(g_comb)$module <- membership(communities)  # si pas fait déjà
seed_module <- V(g_comb)$module[which(V(g_comb)$name == seed_node)]
cat("Seed module id:", seed_module, " ; size:", sum(V(g_comb)$module == seed_module), "\n")
```

```{r}
# Nodes les plus proches et leur module
top_nodes <- names(head(scores, 100))   # top 100 voisins pondérés
top_nodes_df <- data.frame(
  name = top_nodes,
  score = scores[top_nodes],
  module = V(g_comb)$module[match(top_nodes, V(g_comb)$name)],
  stringsAsFactors = FALSE
)
head(top_nodes_df, 20)
```

**Commentaire :**

Le RW permet d’identifier les nœuds les plus accessibles depuis la seed. Les tops noeuds incluent des enzymes glycolytiques (ENO2, PKM, PGAM1, LDHA) et des régulateurs transcriptionnels (HIF1A). Ces noeuds sont fortement connectés dans le module de la seed (module n°8, 121 nœuds).

Concernant le module du seed, il a une taille de 121 noeuds. C'est un module métabolique cohérent, centré sur la glycolyse et régulation transcriptionnelle. Biologiquement, ce module reflète la co-régulation des gènes/protéines glycolytiques, typique de la reprogrammation énergétique cellulaire. Cela confirme l’importance de ce module dans ces processus métaboliques.

### c.5. Analyse d'enrichissement

```{r}
# Crée un dossier temporaire accessible
tmpdir <- "~/Rtmp_clusterProfiler"
dir.create(tmpdir, showWarnings = FALSE)
Sys.setenv(TMPDIR = tmpdir)

# -----------------------------
# 1. Récupérer les nœuds du module 8
# -----------------------------
module_membership <- membership(communities)
modules_list <- split(names(module_membership), module_membership)
module_8_nodes <- modules_list[["8"]]

# -----------------------------
# 2. Fonction pour extraire les gènes utilisables
# -----------------------------
get_genes_for_enrich <- function(nodes) {
  # ENSEMBL
  genes_ensembl <- nodes[grepl("^ENSG", nodes)]
  # SYMBOL
  genes_symbol <- nodes[grepl("^[A-Z0-9]+$", nodes)]
  
  # Retirer doublons et NA
  genes <- unique(c(genes_ensembl, genes_symbol))
  genes <- genes[!is.na(genes)]
  return(genes)
}

# -----------------------------
# 3. Extraire les gènes du module
# -----------------------------
module_8_genes <- get_genes_for_enrich(module_8_nodes)

# -----------------------------
# 4. Enrichissement GO (Biological Process)
# -----------------------------
if(length(module_8_genes) >= 10) {
  
  keytype <- if(any(grepl("^ENSG", module_8_genes))) "ENSEMBL" else "SYMBOL"
  
  ego_8 <- tryCatch(
    enrichGO(
      gene          = module_8_genes,
      OrgDb         = org.Hs.eg.db,
      keyType       = keytype,
      ont           = "BP",
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ),
    error = function(e) {
      message("Erreur enrichGO pour le module 8 : ", e$message)
      return(NULL)
    }
  )
  
  if(!is.null(ego_8)) {
    # Afficher tous les termes enrichis (résumé)
    print(ego_8)
    
    # Top 10 termes
    cat("\n--- Top 10 termes enrichis ---\n")
    print(head(ego_8, 10))
    
    # Stocker le résultat complet dans un data.frame pour export ou analyse ultérieure
    ego_8_df <- as.data.frame(ego_8)
    
    # Exemple : sauvegarde en CSV
    # write.csv(ego_8_df, "module8_GO_BP_enrichment.csv", row.names = FALSE)
    
  } else {
    message("Enrichissement non réalisé pour le module 8.")
  }
  
} else {
  message("Module 8 trop petit pour enrichGO (", length(module_8_genes), " gènes).")
}
```

