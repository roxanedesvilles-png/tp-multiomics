---
title: "Analyse Intégrative Multi-Omique – Dataset T2D"
author: "Amory Antao, Hugo Breton, Appoline Nabi, Roxane Desvilles"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
library(dplyr)
library(tidyr)
library(ggplot2)
library(reshape2)
library(tibble)
library(purrr)
library(tidyverse)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(mixOmics)
library(knitr)
library(gprofiler2)
```

# **1. Contexte et objectifs - Présentation du jeu de données**

# **2. Exploration du dataset**

**Commentaires :**

Chaque bloc (RNA, protéome, cytokynes) contient un nombre distinct de features.

Les échantillons sont partagés et décrits dans sample_info (avec la variable mode : IR vs IS).

```{r}
data_t2d <- readRDS("/home/hugo/Bureau/M2-BI/Metagénomique/Multi-omique/data_t2d.Rds")

# Vérifier les blocs
lapply(data_t2d, dim)

# Nombre d'échantillons et de features
n_samples <- nrow(data_t2d$sample_info)
n_features <- sapply(data_t2d[1:3], ncol)
n_samples; n_features

# Classes disponibles
table(data_t2d$sample_info$mode)
```

**Commentaires :**

Bloc RNA : 8933 features.

Bloc protein : 233 features.

Bloc cytokyne : 66 features.

Il y a 15 échantillons au total. 7 sont insulino-résistants (IR), et 8 sont insulino-sensibles (IS).

# **3. Analyse préliminaire**

## *a. Visualisation des données : par échantillon, par classe, par bloc omique*

**Commentaire :** Pour manipuler plus facilement les données, on transforme les blocs en matrices, puis on utilise tidyverse pour faire un pivot.

```{r}
# Extraction des matrices
rna_mat <- as.matrix(data_t2d$RNA)
prot_mat <- as.matrix(data_t2d$protein)
cyto_mat <- as.matrix(data_t2d$cytokyne)

# Récupération de l'info classe
classes <- data_t2d$sample_info$mode
samples <- rownames(data_t2d$sample_info)

# Fonction pour convertir en tidy format
tidy_block <- function(mat, block_name){
  df <- as.data.frame(mat)
  df$Sample <- rownames(df)
  df$Class <- classes
  df_melt <- melt(df, id.vars=c("Sample","Class"))
  df_melt$Block <- block_name
  return(df_melt)
}

# Tidy pour chaque bloc
df_rna <- tidy_block(rna_mat, "RNA")
df_prot <- tidy_block(prot_mat, "Protein")
df_cyto <- tidy_block(cyto_mat, "Cytokine")

# Combiner tous les blocs
df_all <- bind_rows(df_rna, df_prot, df_cyto)
```

### a.1. Par échantillon

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Sample, y=value, fill=Block)) +
  geom_boxplot() +
  facet_wrap(~Block, scales="free") +
  theme_bw() +
  theme(axis.text.x=element_text(angle=45, hjust=1)) +
  labs(title="Distribution par échantillon", y="Expression")
```

### a.2. Par classe

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Class, y=value, fill=Block)) +
  geom_boxplot() +
  facet_wrap(~Block, scales="free") +
  theme_bw() +
  labs(title="Distribution par classe", y="Expression")
```

### a.3. Par bloc omique

```{r, fig.width=14, fig.height=7}
ggplot(df_all, aes(x=Block, y=value, fill=Block)) +
  geom_boxplot() +
  theme_bw() +
  labs(title="Distribution par bloc omique", y="Expression")
```

## *b. Mise en forme et transformation des données*

**Commentaire :** Il faut d'abord vérifier si les données ont été log-transformées et/ou centrées-réduites.

-   Pour le bloc RNA :

```{r, fig.width=14, fig.height=7}
# Calcul CV par gène
cv_rna <- apply(rna_mat, 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))

# Résumé
summary(cv_rna)

# Histogramme
hist(cv_rna, breaks=50, main="CV RNA", xlab="Coefficient de variation", col="green")
abline(v=0.4, col="red", lwd=2)
```

**Commentaire :** La médiane de la série est d'environ 0.61, avec des valeurs allant de 0.03 à 3.87. On choisit un seuil de 0.4 pour conserver la plupart des gènes.

```{r}
# Filtrage
rna_keep <- !is.na(cv_rna) & cv_rna >= 0.4
rna_filt <- rna_mat[, rna_keep, drop = FALSE]

# Scaling
rna_scaled <- scale(rna_filt)
```

Les données RNA sont normalisées.

-   Pour le bloc protein :

```{r, fig.width=14, fig.height=7}
# Écart-type par protéine (feature)
sd_prot <- apply(prot_mat, 2, sd, na.rm = TRUE)
summary(sd_prot)

# Histogramme
hist(sd_prot, breaks=50, main="SD Protein", xlab="Standard deviation", col="coral")
abline(v=0.4, col="red", lwd=2)
```

**Commentaire :** Ici, on choisit de calculer le sd et non le CV. En effet, les données du bloc protein ont déjà été log-transformées (valeurs très négatives). Calculer le CV n'aurait pas de sens ici.

La médiane étant de 0.58 environ (pour des valeurs allant de 0.096 à 3.29), on choisit un seuil de sd de 0.4, qui semble un bon compromis pour filtrer suffisamment de gènes peu variables, tout en restant permissif.

```{r}
# Filtrage
prot_keep <- !is.na(sd_prot) & sd_prot >= 0.4
prot_filt <- prot_mat[, prot_keep, drop = FALSE]

# Scaling
prot_scaled <- scale(prot_filt)
```

Les données protein sont normalisées.

-   Pour le bloc cytokyne

```{r, fig.width=14, fig.height=7}
# Calcul CV par gène
cv_cyto <- apply(cyto_mat, 2, function(x) sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE))
summary(cv_cyto)

# Histogramme
hist(cv_cyto, breaks=50, main="CV Cytokine", xlab="Coefficient de variation", col="#C8A2C8")
abline(v=0.15, col="red", lwd=2)
```

**Commentaire :** Les valeurs de CV sont positives et petites (de 0.02 à 0.98). On choisit un seuil de 0.15, suffisamment permissif sachant la petite taille de ce bloc dans le dataset.

```{r}
# Filtrage
cyto_keep <- !is.na(cv_cyto) & cv_cyto >= 0.15
cyto_filt <- cyto_mat[, cyto_keep, drop = FALSE]

# Scaling
cyto_scaled <- scale(cyto_filt)
```

Les données cytokyne sont normalisées.

Visualisation des données après preprocessing

```{r, fig.width=14, fig.height=7}
# Supposons que rna_scaled, prot_scaled, cyto_scaled existent après filtrage/scaling
tidy_scaled <- function(mat, block_name){
  df <- as.data.frame(mat)
  df$Sample <- rownames(df)
  df$Class <- classes
  df_melt <- melt(df, id.vars=c("Sample","Class"))
  df_melt$Block <- block_name
  return(df_melt)
}

df_rna_scaled <- tidy_scaled(rna_scaled, "RNA")
df_prot_scaled <- tidy_scaled(prot_scaled, "Protein")
df_cyto_scaled <- tidy_scaled(cyto_scaled, "Cytokine")

df_all_scaled <- bind_rows(df_rna_scaled, df_prot_scaled, df_cyto_scaled)

# Boxplot par bloc après traitement
ggplot(df_all_scaled, aes(x=Block, y=value, fill=Block)) +
  geom_boxplot() +
  theme_bw() +
  labs(title="Distribution par bloc (après filtrage et scaling)", y="Expression (scaled)")
```

## *c. Nombre de features après filtrage*

```{r}
# Nombre de features restantes
sum(rna_keep)    # RNA
sum(prot_keep)   # Protein
sum(cyto_keep)   # Cytokine
```

```{r}
cat("RNA :", sum(rna_keep), "features\n")
cat("Protein :", sum(prot_keep), "features\n")
cat("Cytokine :", sum(cyto_keep), "features\n")
```

**Commentaire :** Il reste 5844 features après filtrage du bloc RNA, 163 features après filtrage du bloc protein, et 28 features après filtrage du bloc cytokyne.

## *d. Gènes et protéines les plus variables*

```{r}
# Pour RNA
top_rna <- sort(cv_rna[rna_keep], decreasing=TRUE)
head(top_rna, 10)  # 10 gènes les plus variables

# Pour Protein
top_prot <- sort(sd_prot[prot_keep], decreasing=TRUE)
head(top_prot, 10)

# Pour Cytokine
top_cyto <- sort(cv_cyto[cyto_keep], decreasing=TRUE)
head(top_cyto, 10)
```

## *e. Ces gènes sont-ils traduits ? Présents dans les données protéomiques ?*

Pour évaluer si les gènes les plus variables au niveau transcriptomique sont traduits, les identifiants ENSEMBL des gènes sélectionnés ont été annotés à l’aide de la base org.Hs.eg.db. Les correspondances SYMBOL et UNIPROT ont été extraites via AnnotationDbi::select().

```{r}
cv_rna_filtered <- cv_rna[rna_keep]

# 1. Annotation : SYMBOL + UNIPROT pour les gènes RNA
res_annot <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = names(cv_rna_filtered),
  keytype = "ENSEMBL",
  columns = c("SYMBOL", "UNIPROT")
)
```

```{r}
# 2. Identifier les gènes les plus variables
top_rna_names <- names(sort(cv_rna_filtered, decreasing = TRUE))[1:10]
top_rna_annot <- res_annot %>% filter(ENSEMBL %in% top_rna_names)
```

```{r}
# 3. Vérifier lesquels sont traduits (ont un UNIPROT)
top_rna_annot$Traduit <- ifelse(is.na(top_rna_annot$UNIPROT), "Non", "Oui")
```

```{r}
# 4. Petit résumé
table(top_rna_annot$Traduit)
```

```{r}
# 5. (Optionnel) – Exporter un tableau propre
top_rna_annot <- top_rna_annot %>%
  dplyr::arrange(desc(ENSEMBL)) %>%
  dplyr::select(ENSEMBL, SYMBOL, UNIPROT, Traduit)

top_rna_annot
```

```{r, fig.width=14, fig.height=7}
traduit_df <- top_rna_annot %>%
  count(Traduit)

ggplot(traduit_df, aes(x = Traduit, y = n, fill = Traduit)) +
  geom_bar(stat = "identity", width = 0.5) +
  geom_text(aes(label = n), vjust = -0.4, size = 5) +
  scale_fill_manual(values = c("Oui" = "mediumorchid", "Non" = "grey70")) +
  theme_bw() +
  labs(
    title = "Proportion de gènes RNA traduits (présents dans le protéome)",
    x = "",
    y = "Nombre de gènes"
  ) +
  theme(
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5),
    legend.position = "none"
  )
```

**Commentaires :** Après filtrage, tous les gènes RNA les plus variables ont une correspondance dans la base UniProt. ls sont donc potentiellement traduits et présents dans le bloc protéomique.

Cela reflète une bonne cohérence entre les blocs RNA et protéomique, malgré les différences d’amplitude observées lors de la normalisation.

# **4. Analyse en composantes principales : PCA et sPCA**

## *a. PCA*

### a.1. PCA sur le bloc RNA

```{r, fig.width=14, fig.height=7}
rna <- rna_scaled
pca_rna <- pca(rna, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_rna, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - RNA")

# Contribution de chaque PC
plotVar(pca_rna, title = "Variables - RNA")

# Évaluer le nombre de PC pertinentes
pca_rna$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_rna$prop_expl_var$X, 3)  # lisible
cumsum(pca_rna$prop_expl_var$X)    # variance cumulée
```

PC1 et PC2 expliquent le mieux la variance des données (32,6% de variance cumulée expliquée).

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_rna <- pca_rna$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_rna, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA RNA")
abline(h=0.09, col="red", lty=2)  # seuil optionnel pour voir les PCs importantes
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_rna <- as.data.frame(pca_rna$variates$X)
pca_scores_rna$sample <- rownames(pca_scores_rna)
pca_scores_rna$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
library(ggrepel)
pca_scores_rna$outlier <- FALSE
center_IR <- colMeans(pca_scores_rna[pca_scores_rna$class=="IR", c("PC1","PC2")])
dist_IR <- sqrt((pca_scores_rna$PC1 - center_IR[1])^2 + (pca_scores_rna$PC2 - center_IR[2])^2)
pca_scores_rna$outlier[which.max(dist_IR)] <- TRUE

ggplot(pca_scores_rna, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  geom_point(data=subset(pca_scores_rna, outlier==TRUE), 
             color="red", size=4, shape=8) +  # point rouge étoilé
  geom_text_repel(data=subset(pca_scores_rna, outlier==TRUE), 
                  aes(label=sample), color="red") +
  stat_ellipse(level=0.95) +
  theme_minimal() +
  labs(title="PCA RNA avec outlier", x="PC1", y="PC2")
```

**Commentaire de l'ellipse :**Les deux groupes IS et IR ont une variance similaire sur PC1 et 2. La dispersion des échantillons est comparable. Le groupe IS est plus homogène (l'ellipse de IS est incluse dans celle d'IR). Cette PCA montre que les principales sources de variations ne distinguent pas parfaitement les deux groupes. D'autres blocs pourraient mieux montrer cette séparation.

L'outlier pourrait avoir un profil transcriptionnel un peu différent.

### a.2. PCA sur le bloc protein

```{r, fig.width=14, fig.height=7}
prot <- prot_scaled
pca_prot <- pca(prot, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_prot, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - Protein")

# Contribution de chaque PC
plotVar(pca_prot, title = "Variables - Protein")

# Évaluer le nombre de PC pertinentes
pca_prot$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_prot$prop_expl_var$X, 3)  # lisible
cumsum(pca_prot$prop_expl_var$X)    # variance cumulée
```

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_prot <- pca_prot$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_prot, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA Protein")
abline(h=0.155, col="red", lty=2)  # seuil optionnel pour voir les PCs importantes
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_prot <- as.data.frame(pca_prot$variates$X)
pca_scores_prot$sample <- rownames(pca_scores_prot)
pca_scores_prot$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
ggplot(pca_scores_prot, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  stat_ellipse(level=0.95) +  # ellipse 95% pour chaque groupe
  theme_minimal() +
  labs(title="PCA Protein", x="PC1", y="PC2")
```

**Commentaire de l'ellipse :**Pour la PCA des protéines, les deux premières composantes principales expliquent une proportion plus élevée de variance que pour les données RNA, ce qui indique que la structure globale des protéines est mieux capturée par les deux premières PC. Les ellipses des groupes IS et IR sont horizontales, mais ont des tailles différentes : le groupe IR présente une dispersion plus large, alors que le groupe IS est plus concentré. Contrairement aux RNA, aucun point n’est un outlier et les chevauchements sont limités, ce qui traduit une séparation plus nette des groupes dans l’espace des deux premières composantes.

### a.3. Pour le bloc cytokyne

```{r, fig.width=14, fig.height=7}
cyto <- cyto_scaled
pca_cyto <- pca(cyto, ncomp = 5, center = TRUE, scale = TRUE)

# Individus colorés par classe
plotIndiv(pca_cyto, group = data_t2d$sample_info$mode, legend = TRUE, title = "PCA - Cytokyne")

# Contribution de chaque PC
plotVar(pca_cyto, title = "Variables - Cytokyne")

# Évaluer le nombre de PC pertinentes
pca_cyto$prop_expl_var$X  # vecteur numérique de la variance expliquée par chaque PC

round(pca_cyto$prop_expl_var$X, 3)  # lisible
cumsum(pca_cyto$prop_expl_var$X)    # variance cumulée
```

```{r, fig.width=14, fig.height=7}
# Extraire la variance expliquée par chaque PC
var_expl_cyto <- pca_cyto$prop_expl_var$X  # vecteur numérique

# Elbow plot
plot(var_expl_cyto, type="b", pch=19, col="steelblue",
     xlab="Composante principale", ylab="Variance expliquée",
     main="Elbow plot PCA Cytokyne")
```

```{r, fig.width=14, fig.height=7}
# Récupérer les coordonnées PCA des échantillons
pca_scores_cyto <- as.data.frame(pca_cyto$variates$X)
pca_scores_cyto$sample <- rownames(pca_scores_cyto)
pca_scores_cyto$class <- data_t2d$sample_info$mode  # ta colonne de classes IS/IR

# Plot PCA avec ellipse
ggplot(pca_scores_cyto, aes(x=PC1, y=PC2, color=class)) +
  geom_point(size=3) +
  stat_ellipse(level=0.95) +  # ellipse 95% pour chaque groupe
  theme_minimal() +
  labs(title="PCA Cytokine", x="PC1", y="PC2")
```

**Commentaire :** Pour la PCA des cytokines, les deux premières composantes expliquent moins de variance que pour les protéines, mais restent informatives. Les ellipses des groupes IS et IR se croisent, indiquant un certain chevauchement entre les profils des deux groupes. Les différentes inclinaisons des ellipses IR et IS traduisentt des orientations différentes de la variation dans l’espace des deux premières PC. Aucun point n’apparaît comme outlier, suggérant que toutes les observations sont relativement cohérentes avec la structure globale des groupes.

## *b. sPCA*

```{r, fig.width=14, fig.height=7}
# Préparer les blocs

# Y = classe IS / IR
Y <- factor(data_t2d$sample_info$mode)

# Les blocs
blocks <- list(
  RNA = rna_scaled,
  Protein = prot_scaled,
  Cytokine = cyto_scaled
)

# sPCA multi-blocs supervisée
spca_res <- block.splsda(
  X = blocks,
  Y = Y,
  ncomp = 2,   # on garde 2 composantes
  keepX = list(
    RNA = c(10, 5),       # 10 features sur comp1, 5 sur comp2
    Protein = c(10, 5),
    Cytokine = c(10, 5)
  ),
  scale = TRUE
)

# Visualiser les échantillons
plotIndiv(spca_res, group = Y, legend = TRUE, ellipse = TRUE, title = "sPCA multi-blocs")

# Extraire les variables retenues
selected_vars <- lapply(names(blocks), function(bloc) {
  lapply(1:2, function(comp) {
    sv <- selectVar(spca_res, block = bloc, comp = comp)
    sv[[bloc]]$name   # $name pour chaque bloc
  })
})
names(selected_vars) <- names(blocks)

# Affichage
selected_vars
```

```{r}
# Extraction propre des variables sélectionnées
selected_features <- list()

for (bloc in names(blocks)) {
  for (comp in 1:2) {
    vars <- selectVar(spca_res, block = bloc, comp = comp)[[bloc]]
    df <- data.frame(
      Block = bloc,
      Comp = comp,
      Feature = vars$name,
      Loading = vars$value
    )
    selected_features[[paste0(bloc, "_comp", comp)]] <- df
  }
}

selected_features_df <- bind_rows(selected_features)
selected_features_df

plotVar(spca_res, comp = c(1, 2), var.names = TRUE,
        title = "Variables retenues par la sPCA (comp1 et comp2)")

circosPlot(spca_res, comp = 1, cutoff = 0.5, line = TRUE)

```
  
# **5. PLS-Da**
  
```{r, fig.width=14, fig.height=8}
# Y = variable de classe
Y <- factor(data_t2d$sample_info$mode)  # IS / IR

# Blocs omiques déjà filtrés et scalés
blocks <- list(
  RNA = rna_scaled,
  Protein = prot_scaled,
  Cytokine = cyto_scaled
)

# Paramètres : ncomp = 2 (deux composantes principales pour visualisation)
# keepX : nombre de variables retenues par composante (ici exemple : 10/5 pour chaque bloc)
plsda_res <- block.splsda(
  X = blocks,
  Y = Y,
  ncomp = 2,
  keepX = list(
    RNA = c(10, 5),
    Protein = c(10, 5),
    Cytokine = c(5, 3)
  ),
  scale = TRUE
)

# -----------------------------
# Visualiser les individus
# -----------------------------
plotIndiv(
  plsda_res,
  group = Y,
  ellipse = TRUE,
  legend = TRUE,
  title = "PLS-DA multi-blocs - T2D (IR vs IS)"
)

# -----------------------------
# Variables les plus contributives
# -----------------------------
top_vars_plsda <- lapply(names(blocks), function(bloc) {
  lapply(1:2, function(comp) {
    selectVar(plsda_res, block = bloc, comp = comp)[[bloc]]
  })
})
names(top_vars_plsda) <- names(blocks)

# Exemple : extraire pour le bloc RNA, composante 1
top_vars_plsda$RNA[[1]]
```
  
*PCA (non supervisée)*

La PCA capture la variance globale des blocs omiques, sans tenir compte de la classe IR/IS.

Sur le plot PCA :
- Les deux premières composantes expliquent une partie significative de la variance (ex : 33% pour RNA, 38% pour les protéines, 59% pour les cytokynes).
- Les groupes IR et IS se chevauchent, surtout pour les blocs RNA et Cytokine.

-> Avantage : permet de détecter la structure naturelle des données, la variance dominante, et des points aberrants.
-> Limite : la séparation des classes n’est pas garantie, car PCA n’utilise pas l’information de classe.


*PLS-DA (supervisée)*

La PLS-DA maximise la covariance entre les blocs et la variable de classe Y.

Sur le plot PLS-DA :
 - Les échantillons sont projetés pour séparer au mieux IR et IS.
 - Les ellipses des groupes sne se chevauchent pas.

-> Avantage : permet de mettre en évidence les variables discriminantes et la séparation des classes.
-> Limite : moins informative sur la variance globale des données, focalisée sur la séparation supervisée.


C'est donc la *PLS-DA* qui permet la meilleur séparation des classes.


# **6. Analyse d’intégration**

## a. PLS

```{r}
# -----------------------------
# Blocs à inclure
# -----------------------------
X_block <- rna_scaled       # matrice RNA
Y_block <- prot_scaled      # matrice Protein

# PLS classique (X → Y)
pls_res <- pls(X_block, Y_block, ncomp = 10, scale = TRUE)

# -----------------------------
# Visualisation des individus dans l'espace X (RNA)
# -----------------------------
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,               # classe IR / IS pour colorer
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

# -----------------------------
# Visualisation des variables (loadings) - Top 20 par composante
# -----------------------------

library(ggplot2)

# Extraire les loadings X (RNA) et Y (Protein)
loadings_X <- pls_res$loadings$X
loadings_Y <- pls_res$loadings$Y

# Fonction pour récupérer les top N variables par composante
get_topN <- function(loadings, N = 20) {
  df_list <- lapply(1:ncol(loadings), function(comp) {
    df <- data.frame(
      Nom = rownames(loadings),
      Loading = loadings[, comp],
      Composante = paste0("Comp", comp),
      stringsAsFactors = FALSE
    )
    df %>% slice_max(order_by = abs(Loading), n = N)
  })
  bind_rows(df_list)
}

topX <- get_topN(loadings_X, N = 20)
topY <- get_topN(loadings_Y, N = 20)

# Ajouter une colonne Bloc pour couleur
topX$Bloc <- "RNA"
topY$Bloc <- "Protein"

top_vars <- bind_rows(topX, topY)

# Plot avec ggplot
ggplot(top_vars, aes(x = reorder(Nom, Loading), y = Loading, fill = Bloc)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Composante, scales = "free") +
  coord_flip() +
  theme_bw() +
  labs(
    title = "Top 20 variables contributives PLS RNA → Protein",
    x = "",
    y = "Loading"
  ) +
  scale_fill_manual(values = c("RNA" = "steelblue", "Protein" = "coral"))

```
  
  
  
```{r}
# -----------------------------
# Blocs à inclure
# -----------------------------
X_block <- rna_scaled       # matrice RNA
Y_block <- prot_scaled      # matrice Protein
Y <- factor(data_t2d$sample_info$mode)  # IS / IR

# -----------------------------
# PLS classique
# -----------------------------
pls_res <- pls(
  X_block, Y_block,
  ncomp = 10,   # deux composantes principales pour visualisation
  scale = TRUE
)

# -----------------------------
# Visualisation des individus (scores)
# -----------------------------
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

# -----------------------------
# Top 20 variables contributives par composante
# -----------------------------
top_vars_list <- list()

for (bloc in c("X", "Y")) {
  ncomp_bloc <- if(bloc == "X") ncol(pls_res$loadings$X) else ncol(pls_res$loadings$Y)
  
  for (comp in 1:ncomp_bloc) {
    sv <- if(bloc == "X") {
      data.frame(
        Nom = rownames(pls_res$loadings$X),
        Loading = pls_res$loadings$X[, comp],
        stringsAsFactors = FALSE
      )
    } else {
      data.frame(
        Nom = rownames(pls_res$loadings$Y),
        Loading = pls_res$loadings$Y[, comp],
        stringsAsFactors = FALSE
      )
    }
    
    df <- sv %>%
      dplyr::mutate(
        Bloc = ifelse(bloc == "X", "RNA", "Protein"),
        Composante = paste0("Comp", comp)
      ) %>%
      dplyr::arrange(desc(abs(Loading))) %>%
      dplyr::slice(1:20)  # top 20
    top_vars_list[[paste0(bloc, "_Comp", comp)]] <- df
  }
}

# Fusionner tous les blocs/composantes
top_vars_pls_df <- bind_rows(top_vars_list)

# Tableau des top 20 variables
knitr::kable(top_vars_pls_df, digits = 3, caption = "Top 20 variables contributives PLS RNA → Protein")

# -----------------------------
# Détermination du nombre optimal de composantes via variance expliquée
# -----------------------------
# Variance expliquée pour X et Y
var_expl_X <- pls_res$prop_expl_var$X
var_expl_Y <- pls_res$prop_expl_var$Y

# Graphique variance expliquée cumulée
par(mfrow = c(1,2))
plot(var_expl_X, type = "b", pch = 19, col = "steelblue",
     xlab = "Composante", ylab = "Variance expliquée (%)",
     main = "Variance expliquée - RNA (X)")
abline(h = 0.05, col = "red", lty = 2)

plot(var_expl_Y, type = "b", pch = 19, col = "darkgreen",
     xlab = "Composante", ylab = "Variance expliquée (%)",
     main = "Variance expliquée - Protein (Y)")
abline(h = 0.05, col = "red", lty = 2)
par(mfrow = c(1,1))
```
  

```{r}
# Variance expliquée par composante
var_expl_X <- pls_res$prop_expl_var$X
var_expl_Y <- pls_res$prop_expl_var$Y

# Préparer les deux datasets pour ggplot
df_var <- data.frame(
  Composante = rep(1:length(var_expl_X), 2),
  Variance = c(var_expl_X, var_expl_Y),
  Bloc = rep(c("RNA (X)", "Protein (Y)"), each = length(var_expl_X))
)

# Elbow plot
ggplot(df_var, aes(x = Composante, y = Variance, color = Bloc)) +
  geom_point(size = 3) +
  geom_line(size = 1) +
  geom_vline(xintercept = 2, linetype = "dashed", color = "red") +  # composante optimale
  theme_minimal() +
  labs(
    title = "Elbow plot - PLS RNA → Protein",
    x = "Composante",
    y = "Variance expliquée",
    color = "Bloc"
  ) +
  scale_color_manual(values = c("steelblue", "darkgreen"))
```
  
```{r}
# Graphique des individus (scores)
plotIndiv(
  pls_res,
  comp = c(1,2),
  group = Y,
  legend = TRUE,
  ellipse = TRUE,
  title = "PLS RNA → Protein - individus"
)

get_top20 <- function(loadings, bloc_name){
  df <- as.data.frame(loadings)
  df$Nom <- rownames(df)
  df_long <- pivot_longer(df, cols = starts_with("Comp"), names_to = "Composante", values_to = "Loading")
  df_long <- df_long %>%
    group_by(Composante) %>%
    slice_max(order_by = abs(Loading), n = 20) %>%
    ungroup() %>%
    mutate(Bloc = bloc_name)
  return(df_long)
}

top20_X <- get_top20(pls_res$loadings$X, "RNA")
top20_Y <- get_top20(pls_res$loadings$Y, "Protein")

top20_all <- bind_rows(top20_X, top20_Y)

# -----------------------------
# Barplot ggplot2
# -----------------------------
ggplot(top20_all, aes(x = reorder(Nom, Loading), y = Loading, fill = Bloc)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Composante, scales = "free_y") +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Top 20 variables contributives PLS RNA → Protein",
    x = "Variable",
    y = "Loading"
  ) +
  scale_fill_manual(values = c("RNA" = "steelblue", "Protein" = "darkgreen"))

# Arrow plot (correlation circle)
plotArrow(pls_res,
          comp = c(1,2),
          group = Y,
          var.names = TRUE,
          title = "PLS RNA → Protein - arrow plot")
```
  
```{r}
# Scores des composantes
scores_X <- pls_res$variates$X
scores_Y <- pls_res$variates$Y

# Corrélation des composantes correspondantes
cor_comp1 <- cor(scores_X[,1], scores_Y[,1])
cor_comp2 <- cor(scores_X[,2], scores_Y[,2])

cor_comp1
cor_comp2
```

*Composante 1* (cor = 0.88) : forte corrélation entre la première composante RNA et Protein.
Cela signifie que les variations transcriptomiques capturent bien la variation protéique.
Les gènes les plus contributifs de cette composante sont donc de bons candidats pour expliquer la variation des protéines.

*Composante 2* (cor = 0.96) : corrélation encore plus forte.
Même les signaux secondaires sont très concordants entre RNA et Protein.
Cela montre que les deux blocs sont très alignés, et que la structure globale du transcriptome se reflète dans le protéome.


*Conclusion* : La PLS révèle une forte cohérence entre les profils RNA et protéine dans ce jeu de données. Les gènes et protéines les plus contributifs des composantes 1 et 2 sont des biomarqueurs potentiels pour différencier les groupes IR vs IS.



## b. sPLS

```{r}
# Blocs à inclure
X_block <- rna_scaled       # matrice RNA
Y_block <- prot_scaled      # matrice Protein

# sPLS supervisée (X → Y)
spls_res <- spls(
  X = X_block,
  Y = Y_block,
  ncomp = 2,
  keepX = c(10, 5),   # top 10 features comp1, 5 sur comp2
  keepY = c(10, 5),   # top 10 features comp1, 5 sur comp2
  scale = TRUE
)

# -----------------------------
# Graphiques
# -----------------------------

# Individus (scores)
plotIndiv(
  spls_res,
  comp = c(1,2),
  group = Y,              # IR / IS
  legend = TRUE,
  ellipse = TRUE,
  title = "sPLS RNA → Protein - individus"
)

# Variables (loadings) – top 10/5 sélectionnées automatiquement
plotVar(
  spls_res,
  comp = c(1,2),
  var.names = TRUE,
  title = "sPLS RNA → Protein - variables sélectionnées"
)

# Arrow plot
plotArrow(
  spls_res,
  comp = c(1,2),
  group = Y,
  var.names = TRUE,
  title = "sPLS RNA → Protein - arrow plot"
)

# -----------------------------
# Variables retenues
# -----------------------------
selected_vars_spls <- list(RNA = list(), Protein = list())

for(comp in 1:2){
  # RNA
  loadings_X <- spls_res$loadings$X[, comp, drop = FALSE]
  selected_vars_spls$RNA[[comp]] <- rownames(loadings_X)[abs(loadings_X) > 0]
  
  # Protein
  loadings_Y <- spls_res$loadings$Y[, comp, drop = FALSE]
  selected_vars_spls$Protein[[comp]] <- rownames(loadings_Y)[abs(loadings_Y) > 0]
}

selected_vars_spls
```

***Fonction biologique ?***



```{r}
# -----------------------------
# 1. Extraire les top variables du PLS RNA→Protein
# -----------------------------
# Top 50 par bloc, composante 1
top_genes_rna <- rownames(pls_res$loadings$X)[order(abs(pls_res$loadings$X[,1]), decreasing = TRUE)[1:50]]
top_genes_prot <- rownames(pls_res$loadings$Y)[order(abs(pls_res$loadings$Y[,1]), decreasing = TRUE)[1:50]]

# -----------------------------
# 2. Convertir les identifiants en SYMBOL humains
# RNA : ENSEMBL → SYMBOL
rna_map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = top_genes_rna,
  keytype = "ENSEMBL",
  columns = c("SYMBOL")
)

# Protein : UNIPROT → SYMBOL
prot_map <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = top_genes_prot,
  keytype = "UNIPROT",
  columns = c("SYMBOL")
)

# Combiner tous les SYMBOLs et retirer NA
top_genes_symbol <- unique(c(rna_map$SYMBOL, prot_map$SYMBOL))
top_genes_symbol <- top_genes_symbol[!is.na(top_genes_symbol)]

# Vérification
print(top_genes_symbol)

# -----------------------------
# 3. Analyse d'enrichissement GO/Reactome
# -----------------------------
if(length(top_genes_symbol) > 0){
  gost_res <- gost(
    query = top_genes_symbol,
    organism = "hsapiens",
    sources = c("GO:BP", "REAC"),
    significant = TRUE,          # filtrer les termes significatifs
    correction_method = "fdr"
  )
  
  # -----------------------------
  # 4. Vérification des résultats
  # -----------------------------
  if(!is.null(gost_res$result) && nrow(gost_res$result) > 0){
    
    # Top 10 termes enrichis par p-value
    top10 <- gost_res$result %>%
      arrange(p_value) %>%
      slice_head(n = 10)
    
    # Barplot
    ggplot(top10, aes(x = reorder(term_name, -log10(p_value)),
                      y = -log10(p_value),
                      fill = source)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      labs(x = "Pathway / GO term",
           y = "-log10(p-value)",
           title = "Enrichissement GO (BP) / Reactome - Top 10") +
      theme_minimal()
    
  } else {
    message("Aucun terme enrichi trouvé pour ces gènes/protéines.")
  }
  
} else {
  message("Aucun gène convertible en SYMBOL humain trouvé. Vérifie tes identifiants.")
}
```




```{r}
```



```{r}
```




```{r}
```



```{r}
```




```{r}
```



```{r}
```
  